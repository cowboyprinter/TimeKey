<!DOCTYPE html>
<html lang="en">
<head>
     <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- SEO Meta Tags -->
    <meta name="description" content="Quantum Defense - Secure the Superintelligence! A mobile-friendly Three.js game where you defend the vault and upgrade your quantum technologies.">
    <meta name="keywords" content="Quantum Defense, quantum encryption, Three.js, mobile game, quantum lock, quantum key, quantum code, vault defense, Prometheus, AI game, browser game">
    <meta name="author" content="Joel Larson">
    <meta property="og:title" content="Quantum Defense - Mobile Game">
    <meta property="og:description" content="Defend the vault, upgrade quantum tech, and secure the superintelligence in this mobile-friendly browser game.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://www.cowboyprinter.com/wp-content/uploads/2025/06/QUANTUM_DEFENSE_brand_product_shot.png">
    <meta property="og:url" content="https://cowboyprinter.github.io/TimeKey/">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Quantum Defense - Mobile Game">
    <meta name="twitter:description" content="Defend the vault and secure the superintelligence in this quantum-themed browser game.">
    <meta name="twitter:image" content="https://www.cowboyprinter.com/wp-content/uploads/2025/06/QUANTUM_DEFENSE_brand_product_shot.png">
    <!-- End SEO Meta Tags -->
        <title>Quantum Defense - Mobile</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #0c1527, #1a2438);
            color: #f1f5f9;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #game-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            display: flex;
            flex-direction: column;
            z-index: 10;
            pointer-events: none;
        }
        
        .mobile-top-bar {
            display: flex;
            justify-content: space-between;
            background: rgba(12, 20, 35, 0.85);
            border-radius: 16px;
            padding: 12px;
            margin-bottom: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(94, 234, 212, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .status-container {
            flex: 1;
            padding: 10px;
            background: rgba(25, 36, 60, 0.6);
            border-radius: 12px;
            margin: 0 6px;
        }
        
        .status-label {
            font-size: 13px;
            color: #a3b8d0;
            margin-bottom: 6px;
            font-weight: 500;
        }
        
        .bar-container {
            height: 12px;
            background: rgba(25, 36, 60, 0.8);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s ease;
            box-shadow: 0 0 8px rgba(94, 234, 212, 0.3);
        }
        
        .status-value {
            font-size: 13px;
            text-align: center;
            margin-top: 5px;
            font-weight: 700;
            color: #e2f3ff;
        }
        
        #research-bar .bar-fill {
            background: linear-gradient(90deg, #0ea5e9, #5eead4);
        }
        
        #integrity-bar .bar-fill {
            background: linear-gradient(90deg, #10b981, #34d399);
        }
        
        #upgrades-container {
            display: flex;
            justify-content: space-between;
            background: rgba(12, 20, 35, 0.85);
            border-radius: 16px;
            padding: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(94, 234, 212, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }
        
        .upgrade-card {
            background: linear-gradient(145deg, #1e2a4a, #172136);
            border-radius: 12px;
            padding: 12px;
            width: 30%;
            text-align: center;
            border: 1px solid rgba(94, 234, 212, 0.2);
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .upgrade-card.active {
            border-color: #5eead4;
            box-shadow: 0 0 15px rgba(94, 234, 212, 0.5);
            transform: translateY(-5px);
            background: linear-gradient(145deg, #223056, #1a2848);
        }
        
        .upgrade-icon {
            font-size: 24px;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(94, 234, 212, 0.7);
        }
        
        .upgrade-name {
            font-size: 13px;
            font-weight: 700;
            margin-bottom: 5px;
            color: #5eead4;
            text-shadow: 0 0 5px rgba(94, 234, 212, 0.5);
        }
        
        .upgrade-level {
            font-size: 12px;
            color: #a3b8d0;
            font-weight: 500;
        }
        
        #mobile-controls {
            position: fixed;
            bottom: 0px;
            left: 0;
            width: 100vw;
            display: flex;
            justify-content: center;
            z-index: 20;
            padding: 0 20px 10px 20px;
            box-sizing: border-box;
            background: none; /* Optional: transparent background */

        }   
         
        #dpad-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 150px;
            height: 150px;
        }
        
        .dpad-center {
            grid-column: 2;
            grid-row: 2;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 28px;
            backdrop-filter: blur(4px);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .dpad-btn {
            background: rgba(20, 30, 50, 0.7);
            border: none;
            border-radius: 16px;
            color: white;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            touch-action: manipulation;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(94, 234, 212, 0.2);
            transition: all 0.1s ease;
        }
        
        .dpad-btn:active {
            background: rgba(30, 45, 75, 0.9);
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }
        
        #btn-up {
            grid-column: 2;
            grid-row: 1;
        }
        
        #btn-down {
            grid-column: 2;
            grid-row: 3;
        }
        
        #btn-left {
            grid-column: 1;
            grid-row: 2;
        }
        
        #btn-right {
            grid-column: 3;
            grid-row: 2;
        }
        
        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 15, 30, 0.96);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        #game-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }
        
        .overlay-content {
            background: linear-gradient(145deg, #1e2a4a, #172136);
            border-radius: 24px;
            padding: 35px 25px;
            text-align: center;
            width: 90%;
            max-width: 450px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(94, 234, 212, 0.4);
        }
        
        .overlay-title {
            font-size: 36px;
            font-weight: 800;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #0ea5e9, #5eead4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 20px rgba(14, 165, 233, 0.4);
        }
        
        .overlay-message {
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 30px;
            color: #d0e8ff;
        }
        
        .btn {
            background: linear-gradient(90deg, #0ea5e9, #5eead4);
            color: #0a1428;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(14, 165, 233, 0.5);
            width: 85%;
            max-width: 280px;
            margin: 15px auto;
            display: block;
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        .btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 25px rgba(14, 165, 233, 0.7);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 30px 0;
        }
        
        .stat-card {
            background: linear-gradient(145deg, #1a243f, #141d35);
            border-radius: 16px;
            padding: 20px 15px;
            border: 1px solid rgba(94, 234, 212, 0.2);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: 800;
            color: #5eead4;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(94, 234, 212, 0.5);
        }
        
        .stat-label {
            font-size: 14px;
            color: #a3b8d0;
            font-weight: 500;
        }
        
        .lab-indicator {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            background: rgba(12, 20, 35, 0.9);
            padding: 10px 25px;
            border-radius: 30px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 15;
            border: 1px solid rgba(94, 234, 212, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            color: #5eead4;
            font-weight: 600;
        }
        
        .lab-indicator.visible {
            opacity: 1;
        }
        
        /* Safe area adjustments for mobile devices */
        @supports (padding: max(0px)) {
            #mobile-controls {
                bottom: max(25px, env(safe-area-inset-bottom));
                position:fixed;
            }
            
            #ui-container {
                padding: max(10px, env(safe-area-inset-top)) 10px 10px;
            }
        }
        
        @media (max-height: 700px) {
            #mobile-controls {
                bottom: 15px;
            }
            
            .dpad-btn, .dpad-center {
                width: 46px;
                height: 46px;
                font-size: 24px;
            }
            
            #dpad-container {
                width: 140px;
                height: 140px;
            }
            
            .lab-indicator {
                bottom: 170px;
                font-size: 14px;
                padding: 8px 20px;
            }
        }
        
        @media (max-height: 600px) {
            .mobile-top-bar {
                padding: 10px;
            }
            
            .status-container {
                padding: 8px;
            }
            
            #upgrades-container {
                padding: 10px;
            }
            
            .upgrade-card {
                padding: 10px;
            }
            
            .upgrade-icon {
                font-size: 20px;
            }
            
            .lab-indicator {
                bottom: 170px;
                font-size: 13px;
            }
            
            #mobile-controls {
                bottom: 10px;
            }
        }
        
        /* Landscape orientation adjustments */
        @media (orientation: landscape) {
            #ui-container {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                padding: 10px;
                display: flex;
                flex-direction: column;
                z-index: 10;
                pointer-events: none;
                flex-grow: 0; /* Added to prevent growing */
            }
            
            .mobile-top-bar {
                width: 70%;
                margin-right: 10px;
            }
            
            #upgrades-container {
                width: 28%;
                flex-direction: column;
                height: fit-content;
                flex-grow: 0; /* Added to prevent growing */
            }
            
            .upgrade-card {
                width: 100%;
                margin-bottom: 10px;
                flex-grow: 0; /* Added to prevent growing */
            }
            
            #mobile-controls {
                bottom: 15px;
            }
            
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-container">
            <div class="mobile-top-bar">
                <div class="status-container">
                    <div class="status-label">Research Progress</div>
                    <div id="research-bar" class="bar-container">
                        <div id="research-bar-fill" class="bar-fill" style="width: 0%"></div>
                    </div>
                    <div id="research-value" class="status-value">0/1000</div>
                </div>
                
                <div class="status-container">
                    <div class="status-label">Vault Integrity</div>
                    <div id="integrity-bar" class="bar-container">
                        <div id="integrity-bar-fill" class="bar-fill" style="width: 100%"></div>
                    </div>
                    <div id="integrity-value" class="status-value">500/500</div>
                </div>
            </div>
            
            <div id="upgrades-container">
                <div id="lock-upgrade" class="upgrade-card">
                    <div class="upgrade-icon">🔒</div>
                    <div class="upgrade-name">Quantum Lock</div>
                    <div id="lock-level" class="upgrade-level">Level 0</div>
                </div>
                
                <div id="key-upgrade" class="upgrade-card">
                    <div class="upgrade-icon">🔑</div>
                    <div class="upgrade-name">Quantum Key</div>
                    <div id="key-level" class="upgrade-level">Level 0</div>
                </div>
                
                <div id="code-upgrade" class="upgrade-card">
                    <div class="upgrade-icon">💻</div>
                    <div class="upgrade-name">Quantum Code</div>
                    <div id="code-level" class="upgrade-level">Level 0</div>
                </div>
            </div>
        </div>
        
        <div id="mobile-controls">
            <div id="dpad-container">
                <button id="btn-up" class="dpad-btn">↑</button>
                <button id="btn-down" class="dpad-btn">↓</button>
                <button id="btn-left" class="dpad-btn">←</button>
                <button id="btn-right" class="dpad-btn">→</button>
                <div class="dpad-center">●</div>
            </div>
        </div>
        
        <div id="lab-indicator" class="lab-indicator">Collecting Quantum Lock...</div>
        
        <div id="game-overlay">
            <div class="overlay-content">
                <h1 class="overlay-title">Quantum Defense</h1>
                <p class="overlay-message">Secure the Superintelligence before the Red Team breaches the vault!</p>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div id="final-research" class="stat-value">0%</div>
                        <div class="stat-label">Research Complete</div>
                    </div>
                    <div class="stat-card">
                        <div id="final-integrity" class="stat-value">100%</div>
                        <div class="stat-label">Vault Integrity</div>
                    </div>
                    <div class="stat-card">
                        <div id="final-level" class="stat-value">0</div>
                        <div class="stat-label">Upgrade Level</div>
                    </div>
                </div>
                
                <p id="outcome-message" class="overlay-message">The battle for superintelligence begins now...</p>
                <button id="restart-btn" class="btn">Begin Quantum Defense</button>
            </div>
        </div>
    </div>

   <script>
    // Game constants and state
    const GAME_STATES = {
        READY: 0,
        PLAYING: 1,
        GAME_OVER: 2,
        VICTORY: 3
    };

    const LAB_TYPES = {
        LOCK: 0,
        KEY: 1,
        CODE: 2
    };
    
    const LAB_NAMES = {
        [LAB_TYPES.LOCK]: "Quantum Lock",
        [LAB_TYPES.KEY]: "Quantum Key",
        [LAB_TYPES.CODE]: "Quantum Code"
    };

    // --- LAB_MESSAGES and related vars now in GLOBAL scope ---
    const LAB_MESSAGES = {
        [LAB_TYPES.LOCK]: [
            "Creating Time Lock...",
            "Time mirroring...",
            "Reverse Time established...",
            "Stand by...",
            "Report to Key Lab..."
        ],
        [LAB_TYPES.KEY]: [
            "Creating Time Key...",
            "Analyzing Time Crystal...",
            "Key locked in reverse time...",
            "Stand by...",
            "Report to Code Lab..."
        ],
        [LAB_TYPES.CODE]: [
            "Import Time Travel code...",
            "Importing multiverses...",
            "Resolving timelines...",
            "Stand by...",
            "Examine Vault Core..."
        ]
    };
    let currentMessageSequence = [];
    let currentMessageIndex = 0;
    let messageDisplayEndTime = 0;
    const MESSAGE_DURATION = 2000; // ms (2.2 seconds per message for readability)
    let activeLabIndicatorTimeout = 0; 
    // --- End of global message vars ---

    // --- Global colors for vault core emissive transition ---
    const VAULT_START_EMISSIVE_COLOR = new THREE.Color(0x0ea5e9); // Calm blue/cyan
    const VAULT_END_EMISSIVE_COLOR = new THREE.Color(0xFFFF33);   // Bright, hopeful yellow
    let currentVaultEmissiveColor = new THREE.Color().copy(VAULT_START_EMISSIVE_COLOR); // Init with start color
    // --- End of global color vars ---

    // Game configuration
    const config = {
        MAX_RESEARCH: 500, // Was 1000, 500 for faster testing
        RESEARCH_PER_VISIT: 15, // Increased for faster testing of upgrades
        RESEARCH_COOLDOWN: 3000, // ms, slightly shorter for testing
        MAX_VAULT_INTEGRITY: 500,
        ENEMY_DAMAGE: 75,
        ENEMY_SPAWN_INTERVAL: 1800, // Initial spawn interval
        ENEMY_SPEED_MIN: 0.1,
        ENEMY_SPEED_MAX: 2.3,
        UPGRADE_EFFECTS: {
            LOCK: level => 0.09 * level, 
            KEY: level => 0.12 * level, 
            CODE: level => 0.18 * level 
        }
        // Config for second wave (will be added later if needed or integrated into enemy spawning)
    };

    // Game state
    let gameState = GAME_STATES.READY;
    let researchProgress = 0;
    let vaultIntegrity = config.MAX_VAULT_INTEGRITY;
    let lastEnemySpawn = 0;
    let lastFreezeTime = 0;
    let freezeDuration = 0;
    
    let upgrades = { lock: 0, key: 0, code: 0 };

    // Three.js variables
    let scene, camera, renderer;
    let player, vault, vaultCore, labs = [], enemies = []; // vaultCore added

    // DOM references
    const researchBar = document.getElementById('research-bar-fill');
    const researchValue = document.getElementById('research-value');
    const integrityBar = document.getElementById('integrity-bar-fill');
    const integrityValue = document.getElementById('integrity-value');
    const lockLevel = document.getElementById('lock-level');
    const keyLevel = document.getElementById('key-level');
    const codeLevel = document.getElementById('code-level');
    const lockUpgrade = document.getElementById('lock-upgrade');
    const keyUpgrade = document.getElementById('key-upgrade');
    const codeUpgrade = document.getElementById('code-upgrade');
    const gameOverlay = document.getElementById('game-overlay');
    const finalResearch = document.getElementById('final-research');
    const finalIntegrity = document.getElementById('final-integrity');
    const finalLevel = document.getElementById('final-level');
    const outcomeMessage = document.getElementById('outcome-message');
    const restartBtn = document.getElementById('restart-btn');
    const labIndicator = document.getElementById('lab-indicator');

    // --- `updateLabMessages` function defined in GLOBAL scope ---
    function updateLabMessages(currentTime) {
        if (currentMessageSequence.length > 0 && currentMessageIndex < currentMessageSequence.length) {
            if (currentTime >= messageDisplayEndTime) {
                labIndicator.textContent = currentMessageSequence[currentMessageIndex];
                labIndicator.classList.add('visible');
                currentMessageIndex++;
                messageDisplayEndTime = currentTime + MESSAGE_DURATION;

                if (activeLabIndicatorTimeout) {
                    clearTimeout(activeLabIndicatorTimeout);
                    activeLabIndicatorTimeout = null;
                }

                if (currentMessageIndex >= currentMessageSequence.length) {
                    activeLabIndicatorTimeout = setTimeout(() => {
                        labIndicator.classList.remove('visible');
                        currentMessageSequence = []; 
                        currentMessageIndex = 0;
                        activeLabIndicatorTimeout = null; 
                    }, MESSAGE_DURATION);
                }
            }
        }
    }
    // --- End of `updateLabMessages` ---

    function initScene() {
        const gameContainer = document.getElementById('game-container');
        function setGameContainerHeightAndResizeThree() { // Renamed for clarity
            gameContainer.style.height = `${window.innerHeight}px`;
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        window.addEventListener('resize', setGameContainerHeightAndResizeThree);
        window.addEventListener('orientationchange', setGameContainerHeightAndResizeThree);
        setGameContainerHeightAndResizeThree(); 
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0c1527);
        scene.fog = new THREE.Fog(0x0c1527, 30, 70); // Adjusted fog based on camera
        
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000); // Slightly less FOV
        camera.position.set(0, 22, 25); // Camera position for good overview
        camera.lookAt(0, 0, 0);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.getElementById('game-container').appendChild(renderer.domElement);
        
        const ambientLight = new THREE.AmbientLight(0x707080); // Brighter ambient
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(15, 30, 20); // Adjusted light position
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024; 
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;    
        directionalLight.shadow.camera.far = 100;  
        // Optional: Adjust shadow camera bounds for better shadow quality if needed
        // directionalLight.shadow.camera.left = -30;
        // directionalLight.shadow.camera.right = 30;
        // directionalLight.shadow.camera.top = 30;
        // directionalLight.shadow.camera.bottom = -30;
        scene.add(directionalLight);
        
        const groundGeometry = new THREE.PlaneGeometry(60, 60); 
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a2438, roughness: 0.95, metalness: 0.05 
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        const gridHelper = new THREE.GridHelper(60, 30, 0x2a3a5a, 0x1a2438); // Adjusted grid
        scene.add(gridHelper);
        
        createVault();
        createLabs();
        createPlayer();
        
        animate(); // Start the single, correct animate loop
    }

    function createVault() {
        const vaultBaseGeometry = new THREE.CylinderGeometry(3.5, 3.5, 1.5, 32);
        const vaultBaseMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x54628b, metalness: 0.6, roughness: 0.2
        });
        vault = new THREE.Mesh(vaultBaseGeometry, vaultBaseMaterial);
        vault.position.set(0, 0.75, 0); 
        vault.castShadow = true;
        vault.receiveShadow = true;
        scene.add(vault);
        
        const coreGeometry = new THREE.SphereGeometry(1.8, 32, 32);
        const coreMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x5eead4, // This is the base color of the sphere material
            emissive: VAULT_START_EMISSIVE_COLOR.clone(), // Initial emissive color
            emissiveIntensity: 0.2, // Initial base for pulse animation
            transparent: true, opacity: 0.8
        });
        vaultCore = new THREE.Mesh(coreGeometry, coreMaterial); // Assign to global vaultCore
        vaultCore.position.y = 1.5; // Position relative to vault base's top (since vault base height is 1.5, its center is 0.75)
        vault.add(vaultCore); // Add core as a child of the vault base
    }

    function createLabs() {
        labs = []; 
        const labPositions = [
            { x: -15, z: 0, type: LAB_TYPES.LOCK, color: 0x10b981, symbol: '🔒' },
            { x: 15, z: 0, type: LAB_TYPES.KEY, color: 0xf59e0b, symbol: '🔑' },
            { x: 0, z: -15, type: LAB_TYPES.CODE, color: 0x8b5cf6, symbol: '💻' }
        ];
        labPositions.forEach(pos => {
            const labMesh = createLabMesh(pos.x, 1.5, pos.z, pos.color, pos.symbol); // y=1.5 for lab base
            labs.push({ type: pos.type, mesh: labMesh, lastVisit: 0 });
        });
    }

    function createLabMesh(x, y, z, color, symbol) { // Renamed to avoid confusion with createLabs array
        const labGeometry = new THREE.BoxGeometry(5, 3, 5);
        const labMaterial = new THREE.MeshStandardMaterial({ 
            color: color, metalness: 0.3, roughness: 0.4
        });
        const lab = new THREE.Mesh(labGeometry, labMaterial);
        lab.position.set(x, y, z); // y is the center of the lab box
        lab.castShadow = true;
        lab.receiveShadow = true;
        scene.add(lab);
        
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const context = canvas.getContext('2d');
        context.fillStyle = '#FFFFFF'; context.font = 'bold 90px Arial'; 
        context.textAlign = 'center'; context.textBaseline = 'middle';
        context.fillText(symbol, 64, 70); 
        
        const texture = new THREE.CanvasTexture(canvas);
        const symbolMaterial = new THREE.MeshStandardMaterial({ 
            map: texture, transparent: true, roughness: 0.7, metalness: 0.1, side: THREE.DoubleSide
        });
        
        const symbolGeometry = new THREE.PlaneGeometry(3, 3); // Slightly larger symbol plane
        const symbolMesh = new THREE.Mesh(symbolGeometry, symbolMaterial);
        symbolMesh.position.y = 1.6; // Position it slightly above the lab's center
        // To make symbol face camera if camera moves around it (billboarding):
        // symbolMesh.lookAt(camera.position); // Call this in animate, or make it a Sprite
        // For now, keeping it static relative to lab:
        symbolMesh.rotation.x = -Math.PI / 4; // Angled slightly
        lab.add(symbolMesh); 
        
        return lab;
    }

    function createPlayer() {
        const geometry = new THREE.CylinderGeometry(0.7, 0.7, 2.2, 16);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x0ea5e9, metalness: 0.4, roughness: 0.3,
            emissive: 0x0a6a9e, emissiveIntensity: 0.3
        });
        player = new THREE.Mesh(geometry, material);
        player.position.set(0, 1.1, 18); 
        player.castShadow = true;
        player.receiveShadow = true; 
        scene.add(player);
        
        const indicatorGeometry = new THREE.ConeGeometry(0.4, 1.0, 4);
        const indicatorMaterial = new THREE.MeshBasicMaterial({ color: 0x34d399 });
        const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
        indicator.position.y = 1.5; 
        indicator.rotation.x = Math.PI;
        player.add(indicator);
    }

    function spawnEnemy() {
        const side = Math.floor(Math.random() * 4); 
        let x, z;
        const spawnDist = 32; // Spawn further out
        switch(side) {
            case 0: x = Math.random() * 56 - 28; z = -spawnDist; break; // Adjusted for larger ground
            case 1: x = spawnDist; z = Math.random() * 56 - 28; break;
            case 2: x = Math.random() * 56 - 28; z = spawnDist; break;
            case 3: x = -spawnDist; z = Math.random() * 56 - 28; break;
        }
        
        const geometry = new THREE.SphereGeometry(0.7, 16, 16);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0xef4444, emissive: 0xef4444, emissiveIntensity: 0.3
        });
        const enemyMesh = new THREE.Mesh(geometry, material);
        enemyMesh.position.set(x, 0.7, z); 
        enemyMesh.castShadow = true;
        scene.add(enemyMesh);
        
        enemies.push({
            mesh: enemyMesh,
            speed: Math.random() * (config.ENEMY_SPEED_MAX - config.ENEMY_SPEED_MIN) + config.ENEMY_SPEED_MIN,
            frozen: false,
            // frozenTime: 0 // Not actively used if just checking freezeActive flag
        });
    }

    function updatePlayer(delta) {
        if (gameState !== GAME_STATES.PLAYING || !player) return; // Added !player check
        
        const speed = 12 * delta; 
        let moved = false;
        const moveDirection = { x: 0, z: 0 };

        if (keys['arrowup'] || keys['w'] || keys['up']) { 
            moveDirection.z = -1; moved = true;
        }
        if (keys['arrowdown'] || keys['s'] || keys['down']) {
            moveDirection.z = 1; moved = true;
        }
        if (keys['arrowleft'] || keys['a'] || keys['left']) {
            moveDirection.x = -1; moved = true;
        }
        if (keys['arrowright'] || keys['d'] || keys['right']) {
            moveDirection.x = 1; moved = true;
        }

        if (moved) {
            player.position.x += moveDirection.x * speed;
            player.position.z += moveDirection.z * speed;
            const angle = Math.atan2(moveDirection.x, moveDirection.z);
            player.rotation.y = angle;
        }
        
        const playAreaHalfSize = 28; // For 60x60 ground
        player.position.x = Math.max(-playAreaHalfSize, Math.min(playAreaHalfSize, player.position.x));
        player.position.z = Math.max(-playAreaHalfSize, Math.min(playAreaHalfSize, player.position.z));
        
        const now = Date.now();
        const playerPos = player.position;
        
        labs.forEach(lab => {
            if (!lab.mesh) return; // Safety check
            const distance = playerPos.distanceTo(lab.mesh.position);
            if (distance < 4.5 && now - lab.lastVisit > config.RESEARCH_COOLDOWN) {
                lab.lastVisit = now;
                researchProgress = Math.min(config.MAX_RESEARCH, researchProgress + config.RESEARCH_PER_VISIT);
                
                switch(lab.type) {
                    case LAB_TYPES.LOCK: upgrades.lock++; lockLevel.textContent = `Level ${upgrades.lock}`; break;
                    case LAB_TYPES.KEY: upgrades.key++; keyLevel.textContent = `Level ${upgrades.key}`; break;
                    case LAB_TYPES.CODE: 
                        upgrades.code++; codeLevel.textContent = `Level ${upgrades.code}`;
                        freezeDuration = config.UPGRADE_EFFECTS.CODE(upgrades.code);
                        lastFreezeTime = now;
                        break;
                }
                
                if (LAB_MESSAGES[lab.type] && LAB_MESSAGES[lab.type].length > 0) {
                    if (activeLabIndicatorTimeout) clearTimeout(activeLabIndicatorTimeout);
                    currentMessageSequence = LAB_MESSAGES[lab.type];
                    currentMessageIndex = 0;
                    messageDisplayEndTime = now -1; // Trigger first message immediately
                }
                
                updateUI();
                
                const cardId = lab.type === LAB_TYPES.LOCK ? 'lock-upgrade' : 
                               lab.type === LAB_TYPES.KEY ? 'key-upgrade' : 'code-upgrade';
                const card = document.getElementById(cardId);
                if (card) {
                    card.classList.add('active');
                    setTimeout(() => card.classList.remove('active'), 1000);
                }
                
                if (researchProgress >= config.MAX_RESEARCH) {
                    endGame(true);
                }
            }
        });
    }

    function updateEnemies(delta) {
        if (gameState !== GAME_STATES.PLAYING) return;
        
        const now = Date.now();
        const freezeActive = (now - lastFreezeTime) < (freezeDuration * 1000);
        
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            if (!enemy.mesh) { // Safety check if mesh was somehow removed improperly
                enemies.splice(i, 1);
                continue;
            }
            
            if (freezeActive) {
                if (!enemy.frozen) {
                    enemy.frozen = true;
                    enemy.mesh.material.color.set(0x3b82f6); 
                    enemy.mesh.material.emissive.set(0x1e5eb8);
                }
            } else if (enemy.frozen) {
                enemy.frozen = false;
                enemy.mesh.material.color.set(0xef4444); 
                enemy.mesh.material.emissive.set(0xef4444);
            }
            
            if (!enemy.frozen) {
                const direction = new THREE.Vector3().subVectors(vault.position, enemy.mesh.position).normalize();
                const currentSpeed = enemy.speed * (1 - Math.min(0.9, config.UPGRADE_EFFECTS.LOCK(upgrades.lock)));
                enemy.mesh.position.add(direction.multiplyScalar(currentSpeed * delta));
                
                if (enemy.mesh.position.distanceTo(vault.position) < 3.5) { 
                    const eliminateChance = Math.min(0.95, config.UPGRADE_EFFECTS.KEY(upgrades.key)); // Cap at 95%
                    if (Math.random() > eliminateChance) {
                        vaultIntegrity -= config.ENEMY_DAMAGE; 
                        updateUI();
                        
                        if (vaultIntegrity <= 0) {
                            vaultIntegrity = 0;
                            endGame(false);
                            return; 
                        }
                    }
                    scene.remove(enemy.mesh);
                    if(enemy.mesh.geometry) enemy.mesh.geometry.dispose(); // Dispose geometry
                    if(enemy.mesh.material) enemy.mesh.material.dispose(); // Dispose material
                    enemies.splice(i, 1);
                    continue;
                }
            }
        }
    }

    function updateUI() {
        const researchPercent = (researchProgress / config.MAX_RESEARCH) * 100;
        researchBar.style.width = `${researchPercent}%`;
        researchValue.textContent = `${researchProgress}/${config.MAX_RESEARCH}`;
        
        const integrityPercent = (vaultIntegrity / config.MAX_VAULT_INTEGRITY) * 100;
        integrityBar.style.width = `${integrityPercent}%`;
        integrityValue.textContent = `${vaultIntegrity}/${config.MAX_VAULT_INTEGRITY}`;
    }

    function endGame(isVictory) {
        gameState = isVictory ? GAME_STATES.VICTORY : GAME_STATES.GAME_OVER;
        
        finalResearch.textContent = `${Math.round((researchProgress / config.MAX_RESEARCH) * 100)}%`;
        finalIntegrity.textContent = `${Math.round((vaultIntegrity / config.MAX_VAULT_INTEGRITY) * 100)}%`;
        finalLevel.textContent = Math.max(upgrades.lock, upgrades.key, upgrades.code);
        
        const titleElement = document.querySelector('#game-overlay .overlay-title');

        if (isVictory) {
            outcomeMessage.textContent = "RESEARCH COMPLETE! Prometheus Secured! Humanity's future is safe thanks to your efforts.";
            outcomeMessage.style.color = "#5eead4";
            if(titleElement) titleElement.textContent = "Quantum Victory!";
        } else {
            outcomeMessage.textContent = "VAULT BREACHED! Prometheus Stolen! The Red Team has captured the superintelligence.";
            outcomeMessage.style.color = "#ef4444";
            if(titleElement) titleElement.textContent = "Breach Detected!";
        }
        gameOverlay.classList.add('visible');
    }

    function restartGame() {
        gameState = GAME_STATES.PLAYING;
        researchProgress = 0;
        vaultIntegrity = config.MAX_VAULT_INTEGRITY;
        lastEnemySpawn = Date.now(); 
        lastFreezeTime = 0;
        freezeDuration = 0;
        
        upgrades = { lock: 0, key: 0, code: 0 };
        lockLevel.textContent = 'Level 0';
        keyLevel.textContent = 'Level 0';
        codeLevel.textContent = 'Level 0';
        
        if(player) player.position.set(0, 1.1, 18); // Ensure player exists
        if(player) player.rotation.y = 0;
        
        enemies.forEach(enemy => {
            if (enemy.mesh) {
                 scene.remove(enemy.mesh);
                 if(enemy.mesh.geometry) enemy.mesh.geometry.dispose();
                 if(enemy.mesh.material) enemy.mesh.material.dispose();
            }
        });
        enemies = [];
        
        labs.forEach(lab => lab.lastVisit = 0);

        if (activeLabIndicatorTimeout) {
            clearTimeout(activeLabIndicatorTimeout);
            activeLabIndicatorTimeout = null;
        }
        currentMessageSequence = [];
        currentMessageIndex = 0;
        messageDisplayEndTime = 0;
        if (labIndicator) labIndicator.classList.remove('visible');
        
        updateUI();
        gameOverlay.classList.remove('visible');
    }

    const keys = {};
    window.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
    });
    window.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
    });

    function setupMobileControls() {
        const buttons = [
            { id: 'btn-up', key: 'up' }, { id: 'btn-down', key: 'down' },
            { id: 'btn-left', key: 'left' }, { id: 'btn-right', key: 'right' }
        ];
        
        const setKeyState = (key, state) => { keys[key] = state; };
        
        buttons.forEach(buttonConfig => {
            const element = document.getElementById(buttonConfig.id);
            if (element) {
                element.addEventListener('touchstart', (event) => {
                    event.preventDefault(); setKeyState(buttonConfig.key, true);
                }, { passive: false });
                element.addEventListener('touchend', () => setKeyState(buttonConfig.key, false));
                element.addEventListener('touchcancel', () => setKeyState(buttonConfig.key, false));
                
                element.addEventListener('mousedown', () => setKeyState(buttonConfig.key, true));
                element.addEventListener('mouseup', () => setKeyState(buttonConfig.key, false));
                element.addEventListener('mouseleave', () => { if (keys[buttonConfig.key]) setKeyState(buttonConfig.key, false);});
            }
        });
    }
    
    // --- Single, Corrected animate function ---
    let lastTime = 0; 
    function animate(time) { 
        requestAnimationFrame(animate);

        const nowForEventTiming = Date.now(); 
        // Use 'time' from requestAnimationFrame for smooth animation delta, it's usually a more precise DOMHighResTimeStamp
        const delta = Math.min(0.1, (time - lastTime) / 1000) || 0.016; // Provide a fallback for delta if time is 0
        lastTime = time;

        if (gameState === GAME_STATES.PLAYING) {
            updatePlayer(delta);
            updateEnemies(delta);
            
            if (nowForEventTiming - lastEnemySpawn > config.ENEMY_SPAWN_INTERVAL) {
                spawnEnemy();
                lastEnemySpawn = nowForEventTiming;
            }
        }
        
        updateLabMessages(nowForEventTiming); 

        if (vaultCore && vaultCore.material && vaultCore.material.emissive) {
            let baseIntensity = 0.2; 
            let minPulseIntensity = 0.1; 
            const progressRatio = Math.min(1, researchProgress / config.MAX_RESEARCH);
            const maxIntensityBoost = 1.8; 
            let currentOverallMaxIntensity = baseIntensity + (progressRatio * maxIntensityBoost);

            currentVaultEmissiveColor.lerpColors(VAULT_START_EMISSIVE_COLOR, VAULT_END_EMISSIVE_COLOR, progressRatio);
            vaultCore.material.emissive.copy(currentVaultEmissiveColor);

            let baseFrequency = 1.0; 
            const maxAdditionalFrequency = 2.5; 
            let currentFrequency = baseFrequency + (progressRatio * maxAdditionalFrequency);
            
            const pulseFactor = (Math.sin(time * 0.001 * currentFrequency * Math.PI * 2) + 1) / 2; 
            
            let targetIntensity = minPulseIntensity + pulseFactor * (currentOverallMaxIntensity - minPulseIntensity);
            vaultCore.material.emissiveIntensity = Math.max(minPulseIntensity, targetIntensity); // Ensure it doesn't go below min
        }
        
        if (player && camera && renderer) { // Ensure all are defined
             camera.position.x = player.position.x;
             camera.position.z = player.position.z + 22; // Camera distance from player
             camera.position.y = 20; // Fixed camera height
             camera.lookAt(player.position.x, player.position.y + 1, player.position.z); // Look slightly above player center
             renderer.render(scene, camera);
        }
    }
    // --- End of animate function ---

    restartBtn.addEventListener('click', () => {
        // No need to check gameState === GAME_STATES.READY, restartGame handles setup
        restartGame(); 
    });

    window.addEventListener('load', () => {
        initScene();
        setupMobileControls();
        updateUI(); // Initial UI state
        gameOverlay.classList.add('visible'); // Show initial overlay
    });
</script>
</body>
</html>